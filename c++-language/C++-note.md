# 多态
多态：是指同样的消息被不同类型的对象接受时导致不同的行为，即调用了不同的函数

多态性：是指一段程序能够处理多种类型对象的能力

形式：重载多态（函数和运算符重载）， 强制多态（强制类型转换）， 类型参数化多态（模版）， 包含多态（继承及虚函数）

1. 重载多态
    1. 重载是多态性的最简单形式，分为函数重载和运算符重载。
    2. 重定义已有的函数称为函数重载。在C++中既允许重载一般函数，也允许重载类的成员函数。如对构造函数进行重载定义，可使程序有几种不同的途径对类对象进行初始化。
    3. C++允许为类重定义已有运算符的语义，使系统预定义的运算符可操作于类对象。如流插入（＜<）运算符和流提取（>>）运算符（原先语义是位移运算）。

2. 强制多态
    1. 强制多态也称类型转换。
    2. 如C++定义了基本数据类型之间的转换规则，即：
        char→short→ int→unsigned→long→unsigned
        long→ float→ double→long double.
    3. 同时，可以在表达式中使用3种强制类型转换表达式：
        ①static_cast<T>（E）；②T（E）；③（T）E，其中E代表运算表达式，T代表一个类型表达式。上述任意一种都可改变编译器所使用的规则，以便按自己的意愿进行所需的类型强制。
        但是强制多态使类型检查复杂化，尤其在允许重载的情况下，导致无法消解的二义性。

3. 类型参数化多态
    1. 参数化多态即：将类型作为函数或类的参数，避免了为各种不同的数据类型编写不同的函数或类，减轻了设计者负担，提高了程序设计的灵活性。
    2. 模板是C++实现参数化多态性的工具，分为函数模板和类模板。类模板中的成员函数均为函数模板，因此函数模板是为类模板服务的。

4. 包含多态
    1. C++中采用虚函数实现包含多态。虚函数为C++提供了更为灵活的多态机制，这种多态性在程序运行时才能确定，因此虚函数是多态性的精华，至少含有一个虚函数的类称为多态类。包含多态在面向对象程序设计中使用十分频繁。
    2. 派生类继承基类的所有操作，或者说，基类的操作能被用于操作派生类的对象。当基类的操作不能适应派生类时，派生类就需要重载基类的操作。

静态联编

    联编 （binding）又称绑定，就是将模块或者函数合并在一起生成可执行代码的处理过程，同时对每个模块或者函数分配内存地址，并且对外部访问也分配正确的内存地址。

    在编译阶段就将函数实现和函数调用绑定起来称静态联编（static binding）。静态联编在编译阶段就必须了解所有的函数或模块执行所需要的信息，它对函数的选择是基于指向对象的指针（或者引用）的类型。C语言中，所有的联编都是静态联编，C++中一般情况下联编也是静态联编。

动态联编

    在程序运行的时候才进行函数实现和函数调用的绑定称为动态联编(dynamic binding) .

    如果在编译“Point *pc=&c”时，只根据兼容性规则检查它的合理性，即检查它是否符合派生类对象的地址可以赋给基类的指针的条件。至于 “pc->area0"调用哪个函数，等到程序运行到这里再决定。

    如果希望 “pc->area（"调用Circle:area（），也就是使类Point的指针PC指向派生类函数area的地址，则需要将Point类的area函数设置成虚函数。

虚函数的定义形式为：
```c
virtual double area（） ｛ return 0；｝//计算面积
```

当调用虚函数时，先通过vptr找到虚函数表，然后再找出虚函数的真正地址，再调用它。

派生类能继承基类的虚函数表，而且只要是和基类同名（参数也相同）的成员函数，无论是否使用virtual声明，它们都自动成为虚函数。如果派生类没有改写继承基类的虚函数，则函数指针调用基类的虚函数。如果派生类改写了基类的虚函数，编译器将重新为派生类的虚函数建立地址，函数指针会调用改写以后的虚函数。

虚函数的调用规则是：根据当前对象，优先调用对象本身的虚成员函数。这和名字支配规律类似，不过虚函数是动态联编的，是在运行时（通过虚函数表中的函数地址）“间接”调用实际上欲联编的函数。

类定义
```c
class 类名 { //类体
    成员列表
};
```
类的数据类型声明
```c
class 类名 {
    数据成员类型 数据成员列表; //数据成员声明
};
```
在类中定义成员函数
```c
class 类名 {    //类体
    返回类型 函数名(形式参数列表) {//成员函数定义
        函数体
    }
};
``

成员函数的声明在类中，定义在类外部，形式：

```c
class 类名｛//类体
    返回类型 函数名（类型1 参数名1，类型2 参数名2..）；
    //成员函数声明
    返回类型 函数名（类型1，类型2.⋯）；
｝；
返回类型 类名：：函数名（形式参数列表）｛ //成员函数定义在类外部实现
    函数体
｝
```

类定义更一般的形式 ：
```c
class 类名｛//类体
    public:1/公有访问权限
        公有的数据成员和成员函数
    protected：//保护访问权限保护的数据成员和成员函数
    private：//私有访问权限
        私有的数据成员和成员函数
｝；
```


1. 在类中声明数据成员
    正如我们所见，类的数据成员的声明类似于普通变量的声明。如果一个类具有多个同一类型的数据成员，则这些成员可以在一个成员声明中指定。
    ```c
    class Cube ｛ //Cube类表示立方体
        …//其他成员
        1ong color；//数据成员
        double x,y, z,side;1/数据成员
    ｝；
    ```

    类的数据成员可以是基本类型、数组、指针、引用、共用体、枚举类型、void指针、const限定等数据类型。例如：

    ```c
    class ADT ｛ //类成员数据类型
        ...//成员函数
        long color:
        double x,y,z,side;1/基本类型int a［10］；//数组char *s；//指针char &r;//引用void *p; //void指针
    ｝；
    ```

    类的数据成员还可以是成员对象（member object），即类类型或结构体类型的对象。若类A中嵌入了类B的对象，称这个对象为子对象（subobject）。例如：类Line嵌入了类Point的子对象start、end。

    ```c
    class Point ｛ //Point类表示点
        public:
            void set(int a,int b); int x, y;
    ｝；
    class Line ｛ //Line类表示线
        public:
            void set(Point a,Point b);
            Point start, end；1/成员对象
    ｝；
    ```
2. 在类中定义或声明数据类型
    1. 除了定义数据成员和成员函数之外，类还可以定义自己的局部类型，并且使用类型别名来简化。
    2. 在类中定义或声明的数据类型的作用域是类内部，因此，它们不能在类外部使用。
    3. 在类定义中，可以定义结构体和共用体类型、嵌套的类定义，声明枚举类型。

1. 在类的外部定义成员函数

    如果成员函数仅有声明在类定义中，则在类外部必须有它的实现，其一般形式：

    返回类型 类名：函数名（形式参数列表）
    ｛
        函数体
    ｝

2. 内联成员函数
    类的成员函数可以指定为inline，即内联函数。
    默认情况下，在类体中定义的成员函数若不包括循环等控制结构，符合内联函数要求时，C++会自动将它们作为内联函数处理（隐式inline）。

    判断成员函数是否是内联的，有以下几条：
        1. 符合内联函数要求；
        2. 符合1的条件，并且在类体中定义，自动成为内联的；
        3. 符合1的条件，在类体显式指明inline，或在外部定义时显式指明inline，或者同时显式指明，则函数是内联的；
        4. 在类外部定义，并且既没有在类体，也没有在外部定义时显式指明inline，则函数不是内联的。

3. 成员函数重载及默认参数
    可以对成员函数重载或使用默认参数。例如：
    ```c
    class MAX {
        int Max(int X, int y) { return x>y?Х:y; }
        int Max() {
            return Max(Max(a, b), Max(c,d));
        } //重载Max
        int Set(int i=1, int j=2, int k=3, int 1=4) {
            a=i, b=j,c=k, d=1;
        } //默认参数
        int a,b,c, d;
    }；
    ```

4. 成员函数的存储方式
    1. 用类实例化一个对象时，系统会为每一个对象分配存储空问。如果一个类包括了数据成员和成员函数，则要分别为数据和函数的代码分配存储空间。
    2. 通常，C++会为每个对象的数据成员分配各自独立的存储空间，像结构体成员那样。

```c
class Point;//Point类声明，非Point类定义，因为没有类体
class Line {
    Point a; 1/错误，不能使用仅有类声明而没有类定义的类定义数据对象
    Point *pp，&rp;/1正确，只有类声明，即可用它定义该类的指针或引用
    Line b;//错误，类不能具有自身类型的数据成员
    Line *p1，&r1；/1正确，类可以有指向自身类型的指针或引用的数据成员
};
```

