
# 1 导言
## 1.1 入门

```c
#include <stdio.h>            // 包含标准库的信息
int main()                    // 定义名为 main 的函数，它不接受参数值
{                             // main函数的语句都被括在花括号中
   printf("hello, world\n");  // main函数调用库函数printf以显示字符序列;
}                             // \n 代表换行符
```

一个C语言程序，无论其大小如何，都是由函数和变量组成的。函数中包含一些语句，以指定所要执行的计算操作;变量则用于存储计算过程中使用的值。

函数之间进行数据交换的一种方法是调用函数向被调用函数提供一个值(称为参数)列表。函数名后面的一对圆括号将参数列表括起来。

调用函数时，只需要使用函数名加上用圆括号括起来的参数表即可。

用双引号括起来的字符序列称为字符串或字符串常量，如"hello, world\n"就是一个字符串。

\n 表示换行； \t 表示制表符;\b 表示回退符;\"表示双引号;\\表示反斜杠符本身
## 1.2 变量与算数表达式
在 C 语言中，所有变量都必须先声明后使用。声明通常放在函数起始处，在任何可执行 语句之前。声明用于说明变量的属性，它由一个类型名和一个变量表组成。

除 int 与 float 类型之外，C 语高还提供了其它一些基本数据类型，例如:
char 字符——一个字节 short 短整型
long 长整型
double 双精度浮点型

while 循环语句的执行方式是这样的:首先测试圆括号中的条件;如果条件为真 (fahr<=upper)，则执行循环体(括在花括号中的 3 条语句);然后再重新测试圆括号中的 条件，如果为真，则再次执行循环体;当圆括号中的条件测试结果为假(fahr>upper)时， 循环结束，并继续执行跟在 while 循环语句之后的下一条语句。

while (fahr <= upper) {
    ...
}

如果某个算术运算符的所有操作数均为整型，则执行整型运算。但是，如果某个算术运 算符有一个浮点型操作数和一个整型操作数，则在开始运算之前整型操作数将会被转换为浮 点型。

%d 按照十进制整型数打印

%6d 按照十进制整型数打印，至少 6 个字符宽

%f 按照浮点数打印

%6f 按照浮点数打印，至少 6 个字符宽

%.2f 按照浮点数打印，小数点后有两位小数

%6.2f 按照浮点数打印，至少 6 个字符宽，小数点后有两位小数

%o 表示八进制数;%x 表示十六进制数;%c 表示字符;%s 表示字符串;%%表示百分号(%)本身。
## 1.3 for 语句
for 语句是一种循环语句，它是对 while 语句的推广。如果将 for 语句与前面介绍的 while 语句比较，就会发现 for 语句的操作更直观一些。圆括号中共包含 3 个部分，各部分 之间用分号隔开。

第一部分是初始化部分，仅在进入循环前执行一次。

第二部分是控制循环的测试或条件部分。循环控制将对该条件求值，如果结果值为真(true)，则执行循环体(本例中的循环体仅包含一个 printf 函数调用语句)。

此后将执行第三部分将循环变量 fahr 增加一个步长，并再次对条件求值。如果计算得到的条件值为假(faise)， 循环将终止执行。

## 1.4 符号常量
#define 指 令可以把符号名(或称为符号常量)定义为一个特定的字符串:

#define 名字 替换文本

在该定义之后，程序中出现的所有在#define 中定义的名字(既没有用引号引起来，也不是 其它名字的一部分)都将用相应的替换文本替换。其中，名字与普通变量名的形式相同:它 们都是以字母打头的字母和数字序列;替换文本可以是任何字符序列，而不仅限于数字。

## 1.5 字符输入/输出
标准库提供了一次读/写一个字符的函数，其中最简单的是 getchar和putchar两个函数。

每次调用时，getchar 函数从文本流中读入下一个输入字符，并将其作为结果值返回。

每次调用 putchar 函数时将打印一个字符。。

### 1.5.1 文件复制
借助于 getchar 与 putchar 函数，可以在不了解其它输入/输出知识的情况下编写出 数量惊人的有用的代码。最简单的例子就是把输入一次一个字符地复制到输出，其基本思想 如下:

读一个字符

while (该字符不是文件结束指示符)

    输出刚读入的字符

    读下一个字符

在没有输入时，getchar 函数将返回一个特殊值，这个特殊值与任何实际字符都不同。这个 值称为 EOF(end of file，文件结束)。

EOF 定义在头文件<stdio.h>中，是个整型数，其具体数值是什么并不重要，只要它与 任何 char 类型的值都不相同即可。这里使用符号常量，可以确保程序不需要依赖于其对应的 任何特定的数值。
### 1.5.2 字符计数

 #include <stdio.h>
 /* count characters in input; 1st version */
 main () {
    long nc;
    nc = 0;
    while (getchar() != EOF) {
        ++nc;
    }

    printf("%ld\n", nc);
 }

该字符计数程序使用 long 类型的变量存放计数值，而没有使用 int 类型的变量。long 整型数(长整型)至少要占用 32 位存储单元。在某些机器上 int 与 long 类型的长度相同， 但在一些机器上，int 类型的值可能只有 16 位存储单元的长度(最大值为 32767)，这样，相 当小的输入都可能使 int 类型的计数变量溢出。转换说明%ld 告诉 printf 函数其对应的参 数是 long 整型。
### 1.5.3 行计数

 #include <stdio.h>
 /* count lines in inout */
 main () {
    int c, nl;
    nl = 0;
    while ((c = getchar()) != EOF) {
        if (c == '\n') {
            ++nl;
        }
    }

    printf("%d\n", nl);
 }

 ### 1.5.4 单词计数

 #include <stdio.h>

 #define IN  /* inside a word */
 #define OUT /* outside a word */

 /* count lines, words,and characters in input */
 main() {
    int c, nl, nw, nc, state;
    state = OUT;
    nl = nw = nc = 0;
    while ((c = getchar()) != EOF) {
        ++nc;
        if (c == '\n') {
            ++nl;
        }
        if (c == ' ' || c == '\n' || c = '\t') {
            state = OUT;
        } else if (state == OUT) {
            state = IN;
            ++nw;
        }
    }

    printf("%d %d %d\n", nl, nw, nc);
 }

## 1.6 数组

数组下标可以是任何整型表达式，包括整型变量(如 i)以及整型常量。


由定义可知，char 类型的字符是小整型，因此 char 类型的变量和常量在算术表达式中 等价于int类型的变量和常量。这样做既自然又方便，例如，c - '0'是一个整型表达式， 如果存储在 c 中的字符是'0'~'9'，其值将为 0~9，因此可以充当数组 ndigit 的合法下 标。

程序中经常使用下列方式表示多路判定:

if (条件1)

语句 1

else if (条件1) 语句 2
...
...
else

在这种方式中，各条件从前往后依次求值，直到满足某个条件，然后执行对应的语句部分。 这部分语句执行完成后，整个语句体执行结束(其中的任何语句都可以是括在花括号中的若 干条语句)。如果所有条件都不满足，则执行位于最后一个 else 之后的语句(如果有的话)。 类似于前面的单词计数程序，如果没有最后一个 else 及对应的语句，该语句体将不执行任何 动作。
## 1.7 函数

函数定义的一般形式为:

返回值类型 函数名(0 个或多个参数声明)

{

声明部分

语句序列

}

我们通常把函数定义中圆括号内列表中出现的变量称为形式参数，而把函数调用中与形 式参数对应的值称为实际参数。

由于 main 本身也是函数， 因此也可以向其调用者返回一个值，该调用者实际上就是程序的执行环境。一般来说，返回 值为 0 表示正常终止，返回值为非 0 表示出现异常情况或出错结束条件。为简洁起见，前面 的 main 函数都省略了 return 语句，但我们将在以后的 main 函数中包含 return 语句， 以提醒大家注意，程序还要向其执行环境返回状态。

合适的参数名能够起到很好的说明性作用，因此我们在函数原型中总是指明参数名。

参数名在圆括号内指定，参数类型在左花括号之前声明。如果没有声明某个参数的类 型，则默认为 int 类型。
## 1.8 参数-传值作用
在 C 语言中，所有函数参数都是“通过值”传递的。也就是说，传递给被调用函数的 参数值存放在临时变量中，而不是存放在原来的变量中。

在 C 语言中，被调用函数不能直接修改主调函数中变量的值，而只 能修改其私有的临时副本的值。


必要时，也可以让函数能够修改主调函数中的变量。这种情况下，调用者需要向被调用 函数提供待设置值的变量的地址(从技术角度看，地址就是指向变量的指针)，而被调用函数 则需要将对应的参数声明为指针类型，并通过它间接访问变量。

如果是数组参数，情况就有所不同了。当把数组名用作参数时，传递给函数的值是数组 起始元素的位置或地址——它并不复制数组元素本身。在被调用函数中，可以通过数组下标 访问或修改数组元索的值。
## 1.9 字符数组
它把第一个参数 s 声明为数组，把第二个参数 lim 声明为整型，声明中提供数组大小的目的是留出存储空间。在 getline 函数中没有必要指明数组 s 的长度，这是因为该数组的大小是在 main 函数中设置的

有些函数返回有用的值，而有些函数(如 copy)仅用于执行一些动作，并不返回值。copy 函数的返回值类型为 void，它显式说明该函数不返回任何值。

getline 函数把字符'\0'(即空字符，其值为 0)插入到它创建的数组的末尾，以标记 字符串的结束。

printf 函数中的格式规范%s 规定，对应的参数必须是以这种形式表示的字符串。
## 1.10 外部变量与作用域
main 函数中的变量(如 line、longest 等)是 main 函数的私自变量或局部变量。由 于它们是在 main 函数中声明的，因此其它函数不能直接访问它们。函数中的每个局部变量只在函数被调用时存在，在函数执行完毕退出时消失。

由于自动变量只在函数调用执行期间存在，因此，在函数的两次调用之间，自动变量不 保留前次调用时的赋值，且在每次进入函数时都要显式为其赋值。如果自动变量没有赋值， 则其中存放的是无效值。

即使在对外部变量赋值的函数返回后， 这些变量仍将保持原来的值不变。

外部变量必须定义在所有函数之外，且只能定义一次，定义后编译程序将为它分配存储单元。

从语法角度看，外部变量的定 义与局部变量的定义是相同的，但由于它们位于各函数的外部，因此这些变量是外部变量。 函数在使用外部变量之前，必须要知道外部变量的名字。
# 2 类型、运算符与表达式
变量和常量是程序处理的两种基本数据对象。声明语句说明变量的名字及类型，也可以指定变量的初值。运算符指定将要进行的操作。表达式则把变量与常量组合起来生成新的值。 对象的类型决定该对象可取值的集合以及可以对该对象执行的操作

## 2.1 变量名
名字是由字母和数字组成的序列，但其第一个字符必须为字母。

选择的变量名要能够尽量从字面上表达变量的用途，这样做不容易引起混淆。局部变量 一般使用较短的变量名(尤其是循环控制变量)，外部变量使用较长的名字。

## 2.2 数据类型及长度

char 字符型，占用一个字节，可以存放本地字符集中的一个字符

int 整型，通常反映了所用机器中整数的最自然长度

float 单精度浮点型

double 双精度浮点型

short 类型通常为 16 位，1ong 类型通常为 32 位，int 类型可以为 16 位或 32 位。

short 与 int 类型至少为 16 位，而 long 类型至少为 32 位，并且 short 类型不得长于 int 类型，而 int 类型不得长于 long 类型。
## 2.3 常量

浮点数常量中包含一个小数点(如 123.4)或一个指数(如 1e-2)，也可以两者都有。 没有后缀的浮点数常量为 double 类型。

带前缀 0 的整型常量表 示它为八进制形式;前缀为 0x 或 0X，则表示它为十六进制形式。八进制与十六进制的常量也可 以使用后缀 L 表示 long 类型，使用后缀 U 表示 unsigned 类型。

一个字符常量是一个整数，书写时将一个字符括在单引号中，如，'x'。

ANSI C语言中的全部转义字符序列如下所示:

\a响铃符  \b回退符

\f换页符  \n换行符

\r 回车符  \t 横向制表符

\v 纵向制表符  \\反斜杠

\?问号  \'单引号

\"双引号  \ooo 八进制数

\xhh 十六进制数

字符常量'\0'表示值为 0 的字符，也就是空字符(null)。我们通常用'\0'的形式代替 0， 以强调某些表达式的字符属性，但其数字值为 0。

在没有显式说明的情况下，enum 类型中第一个枚举名的值为 0，第二个为 1，依此类推。如 果只指定了部分枚举名的值，那么未指定值的枚举名的值将依着最后一个指定值向后递增，

枚举为建立常量值与名字之间的关联提供了一种便利的方式。相对于#define 语句来说， 它的优势在于常量值可以自动生成。尽管可以声明 enum 类型的变量，但编译器不检查这种类 型的变量中存储的值是否为该枚举的有效值。不过，枚举变量提供这种检查，因此枚举比 #define 更具优势。此外，调试程序可以以符号形式打印出枚举变量的值。
## 2.4 声明
所有变量都必须先声明后使用，尽管某些变量可以通过上下文隐式地声明。一个声明指 定一种变量类型，后面所带的变量表可以包含一个或多个该类型的变量。

一个声明语句中的多个变量可以拆开在多个声明语句中声明。

在声明中，如果变量名的后面紧跟一个等号以 及一个表达式，该表达式就充当对变量进行初始化的初始化表达式。

如果变量不是自动变量，则只能进行一次初始化操作，从概念上讲，应该是在程序开始 执行之前进行，并且初始化表达式必须为常量表达式。每次进入函数或程序块时，显式初始 化的自动变量都将被初始化一次，其初始化表达式可以是任何表达式。默认情况下，外部变 量与静态变量将被初始化为 0。未经显式初始化的自动变量的值为未定义值(即无效值)。

任何变量的声明都可以使用 const 限定符限定。该限定符指定变量的值不能被修改。对 数组而言，const 限定符指定数组所有元素的值都不能被修改
## 2.5 算数运算符
二元算术运算符包括:+、-、*、/、%(取模运算符)。整数除法会截断结果中的小数部分。

二元运算符+和-具有相同的优先级，它们的优先级比运算符*、/和%的优先级低，而运 算符*、/和%的优先级又比一元运算符+和-的优先级低。算术运算符采用从左到右的结合规 则。
## 2.6 关系运算符与逻辑运算符
关系运算符包括下列几个运算符:
> >= < <=
它们具有相同的优先级。

逻辑运算符&&与||有一些较为特殊的属性，由&&与||连接的表达式按从左到右的顺序进 行求值，并且，在知道结果值为真或假后立即停止计算。

如果在调用 getchar 函数之前就测试 c 是否为 EOF，结果也是不正确的，因此， 函数的调用与赋值都必须在对 c 中的字符进行测试之前进行。

运算符&&的优先级比||的优先级高，但两者都比关系运算符和相等性运算符的优先级低。

根据定义，在关系表达式或逻辑表达式中，如果关系为真，则表达式的结果值为数值 1;如果为假，则结果值为数值 0。

逻辑非运算符!的作用是将非 0 操作数转换为 0，将操作数 0 转换为 1。
## 2.7 类型转换
一般来说，自动转换是指把“比较窄的”操作数转换为“比较宽的”操作数，并且不丢失信息的转换，不允许使用无意义的表达式，针对可能导致信息丢失的表达式，编译器可能会给出警告信息，比如把较长的整型值赋给较短的整型变量，把浮点型值赋值给整型变量，等等，但这些表达式并不非法。

将字符类型转换为整型时，我们需要注意一点。C 语言没有指定 char 类型的变量是无符 号变量(signed)还是带符号变量(unsigned)。当把一个 char 类型的值转换为 int 类 型的值时，其结果有没有可能为负整数?对于不同的机器，其结果也不同，这反映了不同机 器结构之间的区别。在某些机器中，如果 char 类型值的最左一位为 1，则转换为负整数(进 行“符号扩展”)。而在另一些机器中，把 char 类型值转换为 int 类型时，在 char 类型值 的左边添加 0，这样导致的转换结果值总是正值。

为了保证程序的可移植性，如果要在 char 类型的变量中存储非字符数据， 最好指定 signed 或 unsigned 限定符。

当关系表达式(如 i>j)以及由&&、||连接的逻辑表达式的判定结果为真时，表达式的 值为 1;当判定结果为假时，表达式的值为 0。

C 语言中，很多情况下会进行隐式的算术类型转换。一般来说，如果二元运算符(具有两 个操作数的运算符称为二元运算符，比如+或*)的两个操作数具有不同的类型，那么在进行 运算之前先要把“较低”的类型提升为“较高”的类型，运算的结果为较高的类型。

如果没有 unsigned 类型的操作数，则只要使用下面 这些非正式的规则就可以了:

• 如果其中一个操作数的类型为 long double，则将另一个操作数转换为 1ong double 类型;

• 如果其中一个操作数的类型为 double，则将另一个操作数转换为 double 类型;

• 如果其中一个操作数的类型为 float，则将另一个操作数转换为 float 类型;

• 将 char 与 short 类型的操作数转换为 int 类型;

• 如果其中一个操作数的类型为 long，则将另一个操作数也转换为 long 类型。

当表达式中包含 unsigned 类型的操作数时，转换规则要复杂一些。主要原因在于，带 符号值与无符号值之间的比较运算是与机器相关的，因为它们取决于机器中不同整数类型的 大小。

赋值时也要进行类型转换。赋值运算符右边的值需要转换为左边变量的类型，左边变量 的类型即赋值表达式结果的类型。

在任何表达式中都可以使用一个称为强制类型转换的一元运算符强制进行显式类 型转换。在下列语句中，表达式将按照上述转换规则被转换为类型名指定的类型:

    (类型名) 表达式

我们可以这样来理解强制类型转换的准确含义:在上述语句中，表达式首先被赋值给类型名 指定的类型的某个变量，然后再用该变量替换上述整条语句。

注意，强制类型转换只是生成一 个指定类型的 n 的值，n 本身的值并没有改变。强制类型转换运算符与其它一元运算符具有相 同的优先级。

在通常情况下，参数是通过函数原型声明的。这样，当函数被调用时，声明将对参数进 行自动强制转换。
## 2.8 自增运算符与自减运算符
C 语言提供了两个用于变量递增与递减的特殊运算符。自增运算符++使其操作数递增 1，自减运算符使其操作数递减 1。

++与--这两个运算符特殊的地方主要表现在:它们既可以用作前缀运算符(用在变量前 面，如++n)。也可以用作后缀运算符(用在变量后面，如 n++)。在这两种情况下，其效果都 是将变量 n 的值加 1。但是，它们之间有一点不同。表达式++n 先将 n 的值递增 1，然后再使 用变量 n 的值，而表达式 n++则是先使用变量 n 的值，然后再将 n 的值递增 1。也就是说， 对于使用变量 n 的值的上下文来说，++n 和 n++的效果是不同的。

在不需要使用任何具体值且仅需要递增变量的情况下，前缀方式和后缀方式的效果相同。
## 2.9 按位运算符
C 语言提供了 6 个位操作运算符。这些运算符只能作用于整型操作数，即只能作用于带符号或无符号 char、short、int、long 类型:

& 按位与(AND)

| 按位或(OR)

^ 按位异或(XOR)

<< 左移

>> 右移

~ 按位求反(一元运算符)

按位异或运算符^当两个操作数的对应位不相同时将该位设置为 1，否则，将该位设置为 0。

我们必须将位运算符&、|同逻辑运算符&&、||区分开来，后者用于从左至右求表达式的真值。

移位运算符<<与>>分别用于将运算的左操作数左移与右移，移动的位数则由右操作数指 定(右操作数的值必须是非负值)。

在对 unsigned 类型的无符号值进行右移 位时，左边空出的部分将用 0 填补;当对 signed 类型的带符号值进行右移时，某些机器将 对左边空出的部分用符号位填补(即“算术移位”)，而另一些机器则对左边空出的部分用 0 填补(即“逻辑移位”)。
## 2.10 赋值运算符与表达式
在赋值表达式中，如果表达式左边的变量重复出现在表达式的右边，

其中的运算符+=称为赋值运算符

大多数二元运算符(即有左、右两个操作数的运算符，比如+)都有一个相应的赋值运算 符 op=，其中，op 可以是下面这些运算符之一:

+ - * / % << >> & ^ |
## 2.11 条件表达式
条件表达式(使用三元运算符“? :”)提供了另外一种方法编写这段程序及类似的代码段，在表达式

   expr1 ? expr2 : expr3

中，首先计算 expr1，如果其值不等于 0(为真)，则计算expr2 的值，并以该值作为条件 表达式的值，否则计算expr3 的值，并以该值作为条件表达式的值。expr2 与expr3 中只 能有一个表达式被计算。

条件表达式实际上就是一种表达式，它可以用在其它表达式可以使用的任何 地方;如果 expr2 与 expr3 的类型不同，结果的类型将由本章前面讨论的转换规则决定。

条件表达式中第一个表达式两边的圆括号并不是必须的，这是因为条件运算符?:的优先 级非常低，仅高于赋值运算符。但我们还是建议使用圆括号，因为这可以使表达式的条件部 分更易于阅读。
## 2.12 运算符优先级与求值次序
同一行中 的各运算符具有相同的优先级，各行间从上往下优先级逐行降低。例如，*、/与%三者具有相 同的优先级，它们的优先级都比二元运算符+、-高。运算符( )表示函数调用。
![alt text](./images/2.12.png)

注意，位运算符&、^与|的优先级比运算符==与!=的低。这意味着，位测试表达式，必须用圆括号括起来才能得到正确结果。

函数调用、嵌套赋值语句、自增与自减运算符都有可能产生“副作用”——在对表达式 求值的同时，修改了某些变量的值。在有副作用影响的表达式中，其执行结果同表达式中的 变量被修改的顺序之间存在着微妙的依赖关系。
# 3 控制流
## 3.1 语句与程序块
用一对花括号“{”与“}”把一组声明和语句括在一起就构成了一个复合语句(也叫作 程序块)，复合语句在语法上等价于单条语句。函数体中被花括号括起来的语句便是明显一例。 if、else，while 与 for 之后被花括号括住的多条语句也是类似的例子。(在任何程序块中 都可以声明变量，笫 4 章将对此进行讨论。)右花括号用于结束程序块，其后不需要分号。
## 3.2 if-else语句
if-else 语句用于条件判定，其语法如下所示:

if {表达式}

 语句 1

else

语句 2

该语句执行时，先计算表达式的值，如果其值为真(即表达式的值 为非 0)，则执行语句 1;如果其值为假(即表达式的值为 0)，并且该语句包含 else 部分， 则执行语句 2。

由于 if 语句只是简单测试表达式的数值，因此可以对某些代码的编写进行简化。最明显 的例子是用如下写法

if (表达式)

因为 if-else 语句的 else 部分是可选的，所以在嵌套的 if 语句中省略它的 else 部 分将导致歧义。解决的方法是将每个 else 与最近的前一个没有 else 配对的 if 进行匹配。
## 3.3 else-if 语句

