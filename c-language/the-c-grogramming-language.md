
# 1 导言
## 1.1 入门

```c
#include <stdio.h>            // 包含标准库的信息
int main()                    // 定义名为 main 的函数，它不接受参数值
{                             // main函数的语句都被括在花括号中
   printf("hello, world\n");  // main函数调用库函数printf以显示字符序列;
}                             // \n 代表换行符
```

一个C语言程序，无论其大小如何，都是由函数和变量组成的。函数中包含一些语句，以指定所要执行的计算操作;变量则用于存储计算过程中使用的值。

函数之间进行数据交换的一种方法是调用函数向被调用函数提供一个值(称为参数)列表。函数名后面的一对圆括号将参数列表括起来。

调用函数时，只需要使用函数名加上用圆括号括起来的参数表即可。

用双引号括起来的字符序列称为字符串或字符串常量，如"hello, world\n"就是一个字符串。

\n 表示换行； \t 表示制表符;\b 表示回退符;\"表示双引号;\\表示反斜杠符本身
## 1.2 变量与算数表达式
在 C 语言中，所有变量都必须先声明后使用。声明通常放在函数起始处，在任何可执行 语句之前。声明用于说明变量的属性，它由一个类型名和一个变量表组成。

除 int 与 float 类型之外，C 语高还提供了其它一些基本数据类型，例如:
char 字符——一个字节 short 短整型
long 长整型
double 双精度浮点型

while 循环语句的执行方式是这样的:首先测试圆括号中的条件;如果条件为真 (fahr<=upper)，则执行循环体(括在花括号中的 3 条语句);然后再重新测试圆括号中的 条件，如果为真，则再次执行循环体;当圆括号中的条件测试结果为假(fahr>upper)时， 循环结束，并继续执行跟在 while 循环语句之后的下一条语句。

while (fahr <= upper) {
    ...
}

如果某个算术运算符的所有操作数均为整型，则执行整型运算。但是，如果某个算术运 算符有一个浮点型操作数和一个整型操作数，则在开始运算之前整型操作数将会被转换为浮 点型。

%d 按照十进制整型数打印

%6d 按照十进制整型数打印，至少 6 个字符宽

%f 按照浮点数打印

%6f 按照浮点数打印，至少 6 个字符宽

%.2f 按照浮点数打印，小数点后有两位小数

%6.2f 按照浮点数打印，至少 6 个字符宽，小数点后有两位小数

%o 表示八进制数;%x 表示十六进制数;%c 表示字符;%s 表示字符串;%%表示百分号(%)本身。
## 1.3 for 语句
for 语句是一种循环语句，它是对 while 语句的推广。如果将 for 语句与前面介绍的 while 语句比较，就会发现 for 语句的操作更直观一些。圆括号中共包含 3 个部分，各部分 之间用分号隔开。

第一部分是初始化部分，仅在进入循环前执行一次。

第二部分是控制循环的测试或条件部分。循环控制将对该条件求值，如果结果值为真(true)，则执行循环体(本例中的循环体仅包含一个 printf 函数调用语句)。

此后将执行第三部分将循环变量 fahr 增加一个步长，并再次对条件求值。如果计算得到的条件值为假(faise)， 循环将终止执行。

## 1.4 符号常量
#define 指 令可以把符号名(或称为符号常量)定义为一个特定的字符串:

#define 名字 替换文本

在该定义之后，程序中出现的所有在#define 中定义的名字(既没有用引号引起来，也不是 其它名字的一部分)都将用相应的替换文本替换。其中，名字与普通变量名的形式相同:它 们都是以字母打头的字母和数字序列;替换文本可以是任何字符序列，而不仅限于数字。

## 1.5 字符输入/输出
标准库提供了一次读/写一个字符的函数，其中最简单的是 getchar和putchar两个函数。

每次调用时，getchar 函数从文本流中读入下一个输入字符，并将其作为结果值返回。

每次调用 putchar 函数时将打印一个字符。。

### 1.5.1 文件复制
借助于 getchar 与 putchar 函数，可以在不了解其它输入/输出知识的情况下编写出 数量惊人的有用的代码。最简单的例子就是把输入一次一个字符地复制到输出，其基本思想 如下:

读一个字符

while (该字符不是文件结束指示符)

    输出刚读入的字符

    读下一个字符

在没有输入时，getchar 函数将返回一个特殊值，这个特殊值与任何实际字符都不同。这个 值称为 EOF(end of file，文件结束)。

EOF 定义在头文件<stdio.h>中，是个整型数，其具体数值是什么并不重要，只要它与 任何 char 类型的值都不相同即可。这里使用符号常量，可以确保程序不需要依赖于其对应的 任何特定的数值。
### 1.5.2 字符计数

 #include <stdio.h>
 /* count characters in input; 1st version */
 main () {
    long nc;
    nc = 0;
    while (getchar() != EOF) {
        ++nc;
    }

    printf("%ld\n", nc);
 }

该字符计数程序使用 long 类型的变量存放计数值，而没有使用 int 类型的变量。long 整型数(长整型)至少要占用 32 位存储单元。在某些机器上 int 与 long 类型的长度相同， 但在一些机器上，int 类型的值可能只有 16 位存储单元的长度(最大值为 32767)，这样，相 当小的输入都可能使 int 类型的计数变量溢出。转换说明%ld 告诉 printf 函数其对应的参 数是 long 整型。
### 1.5.3 行计数

 #include <stdio.h>
 /* count lines in inout */
 main () {
    int c, nl;
    nl = 0;
    while ((c = getchar()) != EOF) {
        if (c == '\n') {
            ++nl;
        }
    }

    printf("%d\n", nl);
 }

 ### 1.5.4 单词计数

 #include <stdio.h>

 #define IN  /* inside a word */
 #define OUT /* outside a word */

 /* count lines, words,and characters in input */
 main() {
    int c, nl, nw, nc, state;
    state = OUT;
    nl = nw = nc = 0;
    while ((c = getchar()) != EOF) {
        ++nc;
        if (c == '\n') {
            ++nl;
        }
        if (c == ' ' || c == '\n' || c = '\t') {
            state = OUT;
        } else if (state == OUT) {
            state = IN;
            ++nw;
        }
    }

    printf("%d %d %d\n", nl, nw, nc);
 }

## 1.6 数组

数组下标可以是任何整型表达式，包括整型变量(如 i)以及整型常量。


由定义可知，char 类型的字符是小整型，因此 char 类型的变量和常量在算术表达式中 等价于int类型的变量和常量。这样做既自然又方便，例如，c - '0'是一个整型表达式， 如果存储在 c 中的字符是'0'~'9'，其值将为 0~9，因此可以充当数组 ndigit 的合法下 标。

程序中经常使用下列方式表示多路判定:

if (条件1)

语句 1

else if (条件1) 语句 2
...
...
else

在这种方式中，各条件从前往后依次求值，直到满足某个条件，然后执行对应的语句部分。 这部分语句执行完成后，整个语句体执行结束(其中的任何语句都可以是括在花括号中的若 干条语句)。如果所有条件都不满足，则执行位于最后一个 else 之后的语句(如果有的话)。 类似于前面的单词计数程序，如果没有最后一个 else 及对应的语句，该语句体将不执行任何 动作。
## 1.7 函数

函数定义的一般形式为:

返回值类型 函数名(0 个或多个参数声明)

{

声明部分

语句序列

}

我们通常把函数定义中圆括号内列表中出现的变量称为形式参数，而把函数调用中与形 式参数对应的值称为实际参数。

由于 main 本身也是函数， 因此也可以向其调用者返回一个值，该调用者实际上就是程序的执行环境。一般来说，返回 值为 0 表示正常终止，返回值为非 0 表示出现异常情况或出错结束条件。为简洁起见，前面 的 main 函数都省略了 return 语句，但我们将在以后的 main 函数中包含 return 语句， 以提醒大家注意，程序还要向其执行环境返回状态。

合适的参数名能够起到很好的说明性作用，因此我们在函数原型中总是指明参数名。

参数名在圆括号内指定，参数类型在左花括号之前声明。如果没有声明某个参数的类 型，则默认为 int 类型。
## 1.8 参数-传值作用
在 C 语言中，所有函数参数都是“通过值”传递的。也就是说，传递给被调用函数的 参数值存放在临时变量中，而不是存放在原来的变量中。

在 C 语言中，被调用函数不能直接修改主调函数中变量的值，而只 能修改其私有的临时副本的值。


必要时，也可以让函数能够修改主调函数中的变量。这种情况下，调用者需要向被调用 函数提供待设置值的变量的地址(从技术角度看，地址就是指向变量的指针)，而被调用函数 则需要将对应的参数声明为指针类型，并通过它间接访问变量。

如果是数组参数，情况就有所不同了。当把数组名用作参数时，传递给函数的值是数组 起始元素的位置或地址——它并不复制数组元素本身。在被调用函数中，可以通过数组下标 访问或修改数组元索的值。
## 1.9 字符数组
它把第一个参数 s 声明为数组，把第二个参数 lim 声明为整型，声明中提供数组大小的目的是留出存储空间。在 getline 函数中没有必要指明数组 s 的长度，这是因为该数组的大小是在 main 函数中设置的

有些函数返回有用的值，而有些函数(如 copy)仅用于执行一些动作，并不返回值。copy 函数的返回值类型为 void，它显式说明该函数不返回任何值。

getline 函数把字符'\0'(即空字符，其值为 0)插入到它创建的数组的末尾，以标记 字符串的结束。

printf 函数中的格式规范%s 规定，对应的参数必须是以这种形式表示的字符串。
## 1.10 外部变量与作用域
main 函数中的变量(如 line、longest 等)是 main 函数的私自变量或局部变量。由 于它们是在 main 函数中声明的，因此其它函数不能直接访问它们。函数中的每个局部变量只在函数被调用时存在，在函数执行完毕退出时消失。

由于自动变量只在函数调用执行期间存在，因此，在函数的两次调用之间，自动变量不 保留前次调用时的赋值，且在每次进入函数时都要显式为其赋值。如果自动变量没有赋值， 则其中存放的是无效值。

即使在对外部变量赋值的函数返回后， 这些变量仍将保持原来的值不变。

外部变量必须定义在所有函数之外，且只能定义一次，定义后编译程序将为它分配存储单元。

从语法角度看，外部变量的定 义与局部变量的定义是相同的，但由于它们位于各函数的外部，因此这些变量是外部变量。 函数在使用外部变量之前，必须要知道外部变量的名字。
# 2 类型、运算符与表达式
变量和常量是程序处理的两种基本数据对象。声明语句说明变量的名字及类型，也可以指定变量的初值。运算符指定将要进行的操作。表达式则把变量与常量组合起来生成新的值。 对象的类型决定该对象可取值的集合以及可以对该对象执行的操作

## 2.1 变量名
名字是由字母和数字组成的序列，但其第一个字符必须为字母。

选择的变量名要能够尽量从字面上表达变量的用途，这样做不容易引起混淆。局部变量 一般使用较短的变量名(尤其是循环控制变量)，外部变量使用较长的名字。

## 2.2 数据类型及长度

char 字符型，占用一个字节，可以存放本地字符集中的一个字符

int 整型，通常反映了所用机器中整数的最自然长度

float 单精度浮点型

double 双精度浮点型

short 类型通常为 16 位，1ong 类型通常为 32 位，int 类型可以为 16 位或 32 位。

short 与 int 类型至少为 16 位，而 long 类型至少为 32 位，并且 short 类型不得长于 int 类型，而 int 类型不得长于 long 类型。
## 2.3 常量

浮点数常量中包含一个小数点(如 123.4)或一个指数(如 1e-2)，也可以两者都有。 没有后缀的浮点数常量为 double 类型。

带前缀 0 的整型常量表 示它为八进制形式;前缀为 0x 或 0X，则表示它为十六进制形式。八进制与十六进制的常量也可 以使用后缀 L 表示 long 类型，使用后缀 U 表示 unsigned 类型。

一个字符常量是一个整数，书写时将一个字符括在单引号中，如，'x'。

ANSI C语言中的全部转义字符序列如下所示:

\a响铃符  \b回退符

\f换页符  \n换行符

\r 回车符  \t 横向制表符

\v 纵向制表符  \\反斜杠

\?问号  \'单引号

\"双引号  \ooo 八进制数

\xhh 十六进制数

字符常量'\0'表示值为 0 的字符，也就是空字符(null)。我们通常用'\0'的形式代替 0， 以强调某些表达式的字符属性，但其数字值为 0。

在没有显式说明的情况下，enum 类型中第一个枚举名的值为 0，第二个为 1，依此类推。如 果只指定了部分枚举名的值，那么未指定值的枚举名的值将依着最后一个指定值向后递增，

枚举为建立常量值与名字之间的关联提供了一种便利的方式。相对于#define 语句来说， 它的优势在于常量值可以自动生成。尽管可以声明 enum 类型的变量，但编译器不检查这种类 型的变量中存储的值是否为该枚举的有效值。不过，枚举变量提供这种检查，因此枚举比 #define 更具优势。此外，调试程序可以以符号形式打印出枚举变量的值。
## 2.4 声明
所有变量都必须先声明后使用，尽管某些变量可以通过上下文隐式地声明。一个声明指 定一种变量类型，后面所带的变量表可以包含一个或多个该类型的变量。

一个声明语句中的多个变量可以拆开在多个声明语句中声明。

在声明中，如果变量名的后面紧跟一个等号以 及一个表达式，该表达式就充当对变量进行初始化的初始化表达式。

如果变量不是自动变量，则只能进行一次初始化操作，从概念上讲，应该是在程序开始 执行之前进行，并且初始化表达式必须为常量表达式。每次进入函数或程序块时，显式初始 化的自动变量都将被初始化一次，其初始化表达式可以是任何表达式。默认情况下，外部变 量与静态变量将被初始化为 0。未经显式初始化的自动变量的值为未定义值(即无效值)。

任何变量的声明都可以使用 const 限定符限定。该限定符指定变量的值不能被修改。对 数组而言，const 限定符指定数组所有元素的值都不能被修改
## 2.5 算数运算符
二元算术运算符包括:+、-、*、/、%(取模运算符)。整数除法会截断结果中的小数部分。

二元运算符+和-具有相同的优先级，它们的优先级比运算符*、/和%的优先级低，而运 算符*、/和%的优先级又比一元运算符+和-的优先级低。算术运算符采用从左到右的结合规 则。
## 2.6 关系运算符与逻辑运算符
关系运算符包括下列几个运算符:
> >= < <=
它们具有相同的优先级。

逻辑运算符&&与||有一些较为特殊的属性，由&&与||连接的表达式按从左到右的顺序进 行求值，并且，在知道结果值为真或假后立即停止计算。

如果在调用 getchar 函数之前就测试 c 是否为 EOF，结果也是不正确的，因此， 函数的调用与赋值都必须在对 c 中的字符进行测试之前进行。

运算符&&的优先级比||的优先级高，但两者都比关系运算符和相等性运算符的优先级低。

根据定义，在关系表达式或逻辑表达式中，如果关系为真，则表达式的结果值为数值 1;如果为假，则结果值为数值 0。

逻辑非运算符!的作用是将非 0 操作数转换为 0，将操作数 0 转换为 1。
## 2.7 类型转换
一般来说，自动转换是指把“比较窄的”操作数转换为“比较宽的”操作数，并且不丢失信息的转换，不允许使用无意义的表达式，针对可能导致信息丢失的表达式，编译器可能会给出警告信息，比如把较长的整型值赋给较短的整型变量，把浮点型值赋值给整型变量，等等，但这些表达式并不非法。

将字符类型转换为整型时，我们需要注意一点。C 语言没有指定 char 类型的变量是无符 号变量(signed)还是带符号变量(unsigned)。当把一个 char 类型的值转换为 int 类 型的值时，其结果有没有可能为负整数?对于不同的机器，其结果也不同，这反映了不同机 器结构之间的区别。在某些机器中，如果 char 类型值的最左一位为 1，则转换为负整数(进 行“符号扩展”)。而在另一些机器中，把 char 类型值转换为 int 类型时，在 char 类型值 的左边添加 0，这样导致的转换结果值总是正值。

为了保证程序的可移植性，如果要在 char 类型的变量中存储非字符数据， 最好指定 signed 或 unsigned 限定符。

当关系表达式(如 i>j)以及由&&、||连接的逻辑表达式的判定结果为真时，表达式的 值为 1;当判定结果为假时，表达式的值为 0。

C 语言中，很多情况下会进行隐式的算术类型转换。一般来说，如果二元运算符(具有两 个操作数的运算符称为二元运算符，比如+或*)的两个操作数具有不同的类型，那么在进行 运算之前先要把“较低”的类型提升为“较高”的类型，运算的结果为较高的类型。

如果没有 unsigned 类型的操作数，则只要使用下面 这些非正式的规则就可以了:

• 如果其中一个操作数的类型为 long double，则将另一个操作数转换为 1ong double 类型;

• 如果其中一个操作数的类型为 double，则将另一个操作数转换为 double 类型;

• 如果其中一个操作数的类型为 float，则将另一个操作数转换为 float 类型;

• 将 char 与 short 类型的操作数转换为 int 类型;

• 如果其中一个操作数的类型为 long，则将另一个操作数也转换为 long 类型。

当表达式中包含 unsigned 类型的操作数时，转换规则要复杂一些。主要原因在于，带 符号值与无符号值之间的比较运算是与机器相关的，因为它们取决于机器中不同整数类型的 大小。

赋值时也要进行类型转换。赋值运算符右边的值需要转换为左边变量的类型，左边变量 的类型即赋值表达式结果的类型。

在任何表达式中都可以使用一个称为强制类型转换的一元运算符强制进行显式类 型转换。在下列语句中，表达式将按照上述转换规则被转换为类型名指定的类型:

    (类型名) 表达式

我们可以这样来理解强制类型转换的准确含义:在上述语句中，表达式首先被赋值给类型名 指定的类型的某个变量，然后再用该变量替换上述整条语句。

注意，强制类型转换只是生成一 个指定类型的 n 的值，n 本身的值并没有改变。强制类型转换运算符与其它一元运算符具有相 同的优先级。

在通常情况下，参数是通过函数原型声明的。这样，当函数被调用时，声明将对参数进 行自动强制转换。
## 2.8 自增运算符与自减运算符
C 语言提供了两个用于变量递增与递减的特殊运算符。自增运算符++使其操作数递增 1，自减运算符使其操作数递减 1。

++与--这两个运算符特殊的地方主要表现在:它们既可以用作前缀运算符(用在变量前 面，如++n)。也可以用作后缀运算符(用在变量后面，如 n++)。在这两种情况下，其效果都 是将变量 n 的值加 1。但是，它们之间有一点不同。表达式++n 先将 n 的值递增 1，然后再使 用变量 n 的值，而表达式 n++则是先使用变量 n 的值，然后再将 n 的值递增 1。也就是说， 对于使用变量 n 的值的上下文来说，++n 和 n++的效果是不同的。

在不需要使用任何具体值且仅需要递增变量的情况下，前缀方式和后缀方式的效果相同。
## 2.9 按位运算符
C 语言提供了 6 个位操作运算符。这些运算符只能作用于整型操作数，即只能作用于带符号或无符号 char、short、int、long 类型:

& 按位与(AND)

| 按位或(OR)

^ 按位异或(XOR)

<< 左移

>> 右移

~ 按位求反(一元运算符)

按位异或运算符^当两个操作数的对应位不相同时将该位设置为 1，否则，将该位设置为 0。

我们必须将位运算符&、|同逻辑运算符&&、||区分开来，后者用于从左至右求表达式的真值。

移位运算符<<与>>分别用于将运算的左操作数左移与右移，移动的位数则由右操作数指 定(右操作数的值必须是非负值)。

在对 unsigned 类型的无符号值进行右移 位时，左边空出的部分将用 0 填补;当对 signed 类型的带符号值进行右移时，某些机器将 对左边空出的部分用符号位填补(即“算术移位”)，而另一些机器则对左边空出的部分用 0 填补(即“逻辑移位”)。
## 2.10 赋值运算符与表达式
在赋值表达式中，如果表达式左边的变量重复出现在表达式的右边，

其中的运算符+=称为赋值运算符

大多数二元运算符(即有左、右两个操作数的运算符，比如+)都有一个相应的赋值运算 符 op=，其中，op 可以是下面这些运算符之一:

+ - * / % << >> & ^ |
## 2.11 条件表达式
条件表达式(使用三元运算符“? :”)提供了另外一种方法编写这段程序及类似的代码段，在表达式

   expr1 ? expr2 : expr3

中，首先计算 expr1，如果其值不等于 0(为真)，则计算expr2 的值，并以该值作为条件 表达式的值，否则计算expr3 的值，并以该值作为条件表达式的值。expr2 与expr3 中只 能有一个表达式被计算。

条件表达式实际上就是一种表达式，它可以用在其它表达式可以使用的任何 地方;如果 expr2 与 expr3 的类型不同，结果的类型将由本章前面讨论的转换规则决定。

条件表达式中第一个表达式两边的圆括号并不是必须的，这是因为条件运算符?:的优先 级非常低，仅高于赋值运算符。但我们还是建议使用圆括号，因为这可以使表达式的条件部 分更易于阅读。
## 2.12 运算符优先级与求值次序
同一行中 的各运算符具有相同的优先级，各行间从上往下优先级逐行降低。例如，*、/与%三者具有相 同的优先级，它们的优先级都比二元运算符+、-高。运算符( )表示函数调用。
![alt text](./images/2.12.png)

注意，位运算符&、^与|的优先级比运算符==与!=的低。这意味着，位测试表达式，必须用圆括号括起来才能得到正确结果。

函数调用、嵌套赋值语句、自增与自减运算符都有可能产生“副作用”——在对表达式 求值的同时，修改了某些变量的值。在有副作用影响的表达式中，其执行结果同表达式中的 变量被修改的顺序之间存在着微妙的依赖关系。
# 3 控制流
## 3.1 语句与程序块
用一对花括号“{”与“}”把一组声明和语句括在一起就构成了一个复合语句(也叫作 程序块)，复合语句在语法上等价于单条语句。函数体中被花括号括起来的语句便是明显一例。 if、else，while 与 for 之后被花括号括住的多条语句也是类似的例子。(在任何程序块中 都可以声明变量，笫 4 章将对此进行讨论。)右花括号用于结束程序块，其后不需要分号。
## 3.2 if-else语句
if-else 语句用于条件判定，其语法如下所示:

if {表达式}

 语句 1

else

语句 2

该语句执行时，先计算表达式的值，如果其值为真(即表达式的值 为非 0)，则执行语句 1;如果其值为假(即表达式的值为 0)，并且该语句包含 else 部分， 则执行语句 2。

由于 if 语句只是简单测试表达式的数值，因此可以对某些代码的编写进行简化。最明显 的例子是用如下写法

if (表达式)

因为 if-else 语句的 else 部分是可选的，所以在嵌套的 if 语句中省略它的 else 部 分将导致歧义。解决的方法是将每个 else 与最近的前一个没有 else 配对的 if 进行匹配。
## 3.3 else-if 语句
在 C 语言中我们会经常用到下列结构:

if (表达式)

语句

else if (表达式)

语句

else if (表达式)

语句

else if (表达式)

语句

else

语句

其中的各表 达式将被依次求值，一旦某个表达式结果为真，则执行与之相关的语句，并终止整个语句序 列的执行。同样，其中各语句既可以是单条语句，也可以是用花括号括住的复合语句。

最后一个 else 部分用于处理“上述条件均不成立”的情况或默认情况，也就是当上面各 条件都不满足时的情形。有时候并不需要针对默认情况执行显式的操作，这种情况下，可以 把该结构末尾的

else

语句

部分省略掉;该部分也可以用来检查错误，以捕获“不可能”的条件。
## 3.4 switch语句
switch 语句是一种多路判定语句，它测试表达式是否与一些常量整数值中的某一个值匹 配，并执行相应的分支动作。

switch (表达式) {

case 常量表达式: 语句序列

case 常量表达式: 语句序列

default: 语句序列

每一个分支都由一个或多个整数值常量或常量表达式标记。如果某个分支与表达式的值匹配， 则从该分支开始执行。各分支表达式必须互不相同。如果没有哪一分支能匹配表达式，则执 行标记为 default 的分支。default 分支是可选的。如果没有 default 分支也没有其它分 支与表达式的值匹配，则该 switch 语句不执行任何动作。各分支及 default 分支的排列次 序是任意的。

break 语句将导致程序的执行立即从 switch 语句中退出。在 switch 语句中，case 的作用只是一个标号，因此，某个分支中的代码执行完后，程序将进入下一分支继续执行， 除非在程序中显式地跳转。跳出 switch 语句最常用的方法是使用 break 语句与 return 语 句。
## 3.5 while循环与for循环
while (表达式)
语句

中，首先求表达式的值。如果其值非 0，则执行语句，并再次求该表达式的值。这一循环过程 一直进行下去，直到该表达式的值为 0 为止，随后继续执行语句后面的部分。

for 循环语句;

for (表达式 1; 表达式 2; 表达式 3)

语句

它等价于下列 while 语句:

表达式 1;

while (表达式2) {

语句

表达式 3;
}

最常见的情况是，表达式 1 与表达式 3 是赋值表达式或函数调用，表达式 2 是关系表达式。这 3 个组成部分中的任何部 分都可以省略，但分号必须保留。如果在 for 语句中省略表达式 1 与表达式 3，它就退化成 了 while 循环语句。如果省略测试条件，即表达式 2，则认为其值永远是真值，因此，下列 for 循环语句:
```c
for (;;) {
    ...
}
```
是一个“无限”循环语句，这种语句需要借助其它手段(如 break 语句或 return 语句)才能终止执行。

因为其中没有初始化或重新初始化的操作，所以使用 whi1e 循环语句更自然一些。

如果语句中需要执行简单的初始化和变量递增，使用 for 语句更合适一些，它将循环控制语句集中放在循环的开头，结构更紧凑、更清晰。通过下列语句可以很明显地看出这一点:
 ```c
   for (i = 0; i < n; i++)
      ...
```

逗号运算符“,”也是 C 语言优先级最低的运算符，在 for 语句中经常会用到它。被逗 号分隔的一对表达式将按照从左到右的顺序进行求值，表达式右边的操作数的类型和值即为 其结果的类型和值。
## 3.6 do-while循环
C 语言中的第三种循环——do-while 循环则在循环体执行后测试终止条件， 这样循环体至少被执行一次。

do-while 循环的语法形式如下:
```c
do
    语句
while (表达式);
```
先执行循环体中的语句部分，然后再求表达式的值。如果表达式的值为真， 则再次执行语句，依此类推。当表达式的值变为假，则循环终止
## 3.7 break语句与continue语句
不通过循环头部或尾部的条件测试而跳出循环，有时是很方便的。break 语句可用于从 for、while 与 do-while 等循环中提前退出，就如同从 switch 语句中提前退出一样。break 语句能使程序从 switch 语句或最内层循环中立即跳出。

continue 语句与 break 语句是相关联的，但它没有 break 语句常用。continue 语 句用于使 for、while 或 do-while 语句开始下一次循环的执行。在 while 与 do-while 语句中，continue 语句的执行意味着立即执行测试部分;在 for 循环中，则意味着使控制 转移到递增循环变量部分。continue 语句只用于循环语句，不用于 switch 语句。某个循 环包含的 switch 语句中的 continue 语句，将导致进入下一次循环。
## 3.8 goto语句与标号
C 语言提供了可随意滥用的 goto 语句以及标记跳转位置的标号。从理论上讲，goto 语 句是没有必要的，实践中不使用 goto 语句也可以很容易地写出代码。

最常见的用法是终止程序在某些深度嵌套 的结构中的处理过程，例如一次跳出两层或多层循环。这种情况下使用 break 语句是不能达 到目的的，它只能从最内层循环退出到上一级的循环。下面是使用 goto 语句的一个例子:
```c
for ( ... )
    for ( ... ) {
             ...
             if (disaster)
                goto error;
    } ...
error:
/* clean up the mess */
```
在该例子中，如果错误处理代码很重要，并且错误可能出现在多个地方，使用 goto 语句将会 比较方便。

标号的命名同变量命名的形式相同，标号的后面要紧跟一个冒号。标号可以位于对应的 goto 语句所在函数的任何语句的前面。标号的作用域是整个函数。

所有使用了 goto 语句的程序代码都能改写成不带 goto 语句的程序，但可能会增加一些 额外的重复测试或变量。

# 4 函数与程序结构
## 4.1 函数的基本常识
函数的定义形式如下:

返回值类型 函数明(参数声明表)
{
    声明和语句
}

函数定义中的各构成部分都可以省略。最简单的函数如下所示:
```c
dummy() {}
```
该函数不执行任何操作也不返回任何值。这种不执行任何操作的函数有时很有用，它可以在 程序开发期间用以保留位置(留待以后填充代码)。如果函数定义中省略了返回值类型，则默 认为 int 类型。


被调用函数通过 return 语句向调用者返回值，return 语句的后面可以跟任何表达式:

        return 表达式;

调用函数可以忽略返回值。并且，return 语句的后面也不一定需要表达式。当 return 语句的后面没有表达式时，函数将不向调用者返回值。当被调用函数执行到最后的右花括号 而结束执行时，控制同样也会返回给调用者(不返回值)。如果某个函数从一个地方返回时有 返回值，而从另一个地方返回时没有返回值，该函数并不非法，但可能是一种出问题的征兆。 在任何情况下，如果函数没有成功地返回一个值，则它的“值”肯定是无用的。
## 4.2 返回非整型值的函数

我们通过函数 atof(s)来说明函数返回非整型值的方法。该函数把字符串 s 转换为相应的双精度浮点数。

首先，由于 atof 函数的返回值类型不是 int，因此该函数必须声明返回值的类型。返回 值的类型名应放在函数名字之前

其次，调用函数必须知道 atof 函数返回的是非整型值，这一点也是很重要的。为了达到 该目的，一种方法是在调用函数中显式声明 atof 函数。

函数 atof 的声明与定义必须一致。如果 atof 函数与调用它的主函数 main 放在同一源 文件中，并且类型不一致，编译器就会检测到该错误。但是，如果 atof 函数是单独编译的(这 种可能性更大)，这种不匹配的错误就无法检测出来，atof 函数将返回 double 类型的值， 而 main 函数却将返回值按照 int 类型处理，最后的结果值毫无意义。

如果先前没有声明过的一个名字出现在某个表达式中，并且其后紧跟一个左圆括号，那么上 下文就会认为该名字是一个函数名字，该函数的返回值将被假定为 int 类型，但上下文并不 对其参数作任何假设。并且，如果函数声明中不包含参数

表达式的值在返回之前将被转换为函数的类型。因为函数 atoi 的返回值为 int 类型， 所以，return 语句中的 atof 函数的 double 类型值将被自动转换为 int 类型值。但是， 这种操作可能会丢失信息，某些编译器可能会对此给出警告信息。在该函数中，由于采用了 类型转换的方法显式表明了所要执行的转换操作，因此可以防止有关的警告信息。
## 4.3 外部变量

C 语言程序可以看成由一系列的外部对象构成，这些外部对象可能是变量或函数。

外部变量定 义在函数之外，因此可以在许多函数中使用。由于 C 语言不允许在一个函数中定义其它函数， 因此函数本身是“外部的”。默认情况下，外部变量与函数具有下列性质:通过同一个名字对 外部变量的所有引用(即使这种引用来自于单独编译的不同函数)实际上都是引用同一个对 象(标准中把这一性质称为外部链接)。在这个意义上，外部变量类似于 Fortran 语言的 COMMON 块或 Pascal 语言中在最外层程序块中声明的变量。

因为外部变量可以在全局范围内访问，这就为函数之间的数据交换提供了一种可以代替 函数参数与返回值的方式。任何函数都可以通过名字访问一个外部变量，当然这个名字需要 通过某种方式进行声明。

因为外部变量可以在全局范围内访问，这就为函数之间的数据交换提供了一种可以代替 函数参数与返回值的方式。任何函数都可以通过名字访问一个外部变量，当然这个名字需要 通过某种方式进行声明。

计算器程序的实现很简单。每个操作数都被依次压入到栈中;当一个运算符到达时，从 栈中弹出相应数目的操作数(对二元运算符来说是两个操作数)，把该运算符作用于弹出的操 作数，并把运算结果再压入到栈中。
```c
while (下一个运算符或操作数不是文件结束指示符)
    if (是数)
        将该数压入到栈中
    else if (是运算符)
      弹出所需数目的操作数
      执行运算
      将结果压入到栈中
    else if (是换行符)
        弹出并打印栈顶的值
    else
        出错
```
栈的压入与弹出操作比较简单，但是，如果把错误检测与恢复操作都加进来，该程序就 显得很长了，最好把它们设计成独立的函数，而不要把它们作为程序中重复的代码段使用。 另外还需要一个单独的函数来取下一个输入运算符或操作数。

如果变量定义在任何函数的外部，则是外部变量。

程序中经常会出现这样的情 况:程序不能确定它已经读入的输入是否足够，除非超前多读入一些输入。读入一些字符以 合成一个数字的情况便是一例:在看到第一个非数字字符之前，已经读入的数的完整性是不 能确定的。由于程序要超前读入一个字符，这样就导致最后有一个字符不属于当前所要读入 的数。

如果能“反读”不需要的字符，该问题就可以得到解决。每当程序多读入一个字符时， 就把它压回到输入中，对代码其余部分而言就好像没有读入该字符一样。我们可以编写一对 互相协作的函数来比较方便地模拟反取字符操作。getch 函数用于读入下一个待处理的字符， 而 ungetch 函数则用于把字符放回到输入中，这样，此后在调用 getch 函数时，在读入新 的输入之前先返回 ungetch 函数放回的那个字符。

ungetch 函数把要压回的字符放到一个共享缓冲 区(字符数组)中，当该缓冲区不空时，getch 函数就从缓冲区中读取字符;当缓冲区为空 时，getch 函数调用 getchar 函数直接从输入中读字符。这里还需要增加一个下标变量来记 住缓冲区中当前字符的位置。

由于缓冲区与下标变量是供 getch 与 ungetch 函数共享的，且在两次调用之间必须保 持值不变，因此它们必须是这两个函数的外部变量。
## 4.4 作用域规则
名字的作用域指的是程序中可以使用该名字的部分。对于在函数开头声明的自动变量来 说，其作用域是声明该变量名的函数。不同函数中声明的具有相同名字的各个局部变量之间 没有任何关系。函数的参数也是这样的，实际上可以将它看作是局部变量。

外部变量或函数的作用域从声明它的地方开始，到其所在的(待编译的)文件的末尾结 束。

另一方面，如果要在外部变量的定义之前使用该变量，或者外部变量的定义与变量的使用不在同一个源文件中，则必须在相应的变量声明中强制性地使用关键字 extern。

将外部变量的声明与定义严格区分开来很重要。变量声明用于说明变量的属性(主要是 变量的类型)，而变量定义除此以外还将引起存储器的分配。

在一个源程序的所有源文件中，一个外部变量只能在某个文件中定义一次，而其它文件 可以通过 extern 声明来访问它(定义外部变量的源文件中也可以包含对该外部变量的 extern 声明)。外部变量的定义中必须指定数组的长度，但 extern 声明则不一定要指定数 组的长度。

外部变量的初始化只能出现在其定义中。
## 4.5 头文件
如果该程序的各组 成部分很长，这么做还是有必要的。我们这样分割:将主函数 main 单独放在文件 main.c 中;将 push 与 pop 函数以及它们使用的外部变量放在第二个文件 stack.c 中;将 getop 函数放在第三个文件 getop.c 中;将 getch 与 ungetch 函数放在第四个文件 getch.c 中。 之所以分割成多个文件，主要是考虑在实际的程序中，它们分别来自于单独编译的库。

我们尽可能把共享的部分集 中在一起，这样就只需要一个副本，改进程序时也容易保证程序的正确性。我们把这些公共 部分放在头文件 calc.h 中，在需要使用该头文件时通过#include 指令将它包含进来
![alt text](./images/4.5-1.png)
对于某些中等规模的程序，最好只用一个头文件存放程序中各部分共享的对象。较大的程序需要 使用更多的头文件，我们需要精心地组织它们。
## 4.6 静态变量
某些变量，比如文件 stack.c 中定义的变量 sp 与 val 以及文件 getch.c 中定义的变 量 buf 与 bufp，它们仅供其所在的源文件中的函数使用，其它函数不能访问。用 static 声明限定外部变量与函数，可以将其后声明的对象的作用域限定为被编译源文件的剩余部分

要将对象指定为静态存储，可以在正常的对象声明之前加上关键字 static 作为前缀。

外部的 static 声明通常多用于变量，当然，它也可用于声明函数。

如果把函数声明为 static 类型，则该函数名除了对该函数声明所在的文件可见外，其它文件都无法访问。

static 也可用于声明内部变量。static 类型的内部变量同自动变量一样，是某个特定 函数的局部变量，只能在该函数中使用，但它与自动变量不同的是，不管其所在函数是否被 调用，它一直存在，而不像自动变量那样，随着所在函数的被调用和退出而存在和消失。换 句话说，static 类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间的变 量。
## 4.7 寄存器变量
register 声明告诉编译器，它所声明的变量在程序中使用频率较高。其思想是，将 register 变量放在机器的寄存器中，这样可以使程序更小、执行速度更快。但编译器可以 忽略此选项。

register 声明的形式如下所示:
```c

register int x;
register char c;

```
register 声明只适用于自动变量以及函数的形式参数。

实际使用时，底层硬件环境的实际情况对寄存器变量的使用会有一些限制。每个函数中 只有很少的变量可以保存在寄存器中，且只允许某些类型的变量。但是，过量的寄存器声明 并没有什么害处，这是因为编译器可以忽略过量的或不支持的寄存器变量声明。另外，无论 寄存器变量实际上是不是存放在寄存器中，它的地址都是不能访问的。在不同的机器中，对寄存器变量的数目和类型的具体限制也
## 4.8 程序块结构
C 语言并不是 Pascal 等语言意义上的程序块结构的语言，它不允许在函数中定义函数。但 是，在函数中可以以程序块结构的形式定义变量。变量的声明(包括初始化)除了可以紧跟 在函数开始的花括号之后，还可以紧跟在任何其它标识复合语句开始的左花括号之后。以这 种方式声明的变量可以隐藏程序块外与之同名的变量，它们之间没有任何关系，并在与左花 括号匹配的右花括号出现之前一直存在。

在一个好的程序设计风格中，应该避免出现变量名隐藏外部作用域中相同名字的情况， 否则，很可能引起混乱和错误。
## 4.9 初始化
在不进行显式初始化的情况下，外部变量和静态变量都将被初始化为 0，而自动变量和寄 存器变量的初值则没有定义(即初值为无用的信息)。

定义标量变量时，可以在变量名后紧跟一个等号和一个表达式来初始化变量

对于外部变量与静态变量来说，初始化表达式必须是常量表达式，且只初始化一次(从概念 上讲是在程序开始执行前进行初始化)。对于自动变量与寄存器变量，则在每次进入函数或程 序块时都将被初始化。

自动变量的初始化等效于简写的赋值语句

数组的初始化可以在声明的后面紧跟一个初始化表达式列表，初始化表达式列表用花括 号括起来，各初始化表达式之间通过逗号分隔。

当省略数组的长度时，编译器将把花括号中初始化表达式的个数作为数组的长度

如果初始化表达式的个数比数组元索数少，则对外部变量、静态变量和自动变量来说， 没有初始化表达式的元素将被初始化为 0，如果初始化表达式的个数比数组元素数多，则是错 误的。不能一次将一个初始化表达式指定给多个数组元素，也不能跳过前面的数组元素而直 接初始化后面的数组元素。

字符数组的初始化比较特殊:可以用一个字符串来代替用花括号括起来并用逗号分隔的 初始化表达式序列
## 4.10 递归
C 语言中的函数可以递归调用，即函数可以直接或间接调用自身。

函数递归调用自身时，每次调用都会得到一个与以前的自动变量集合不同的新的自动变 量集合。

一个能较好说明递归的例子是快速排序。对于一个给定的数组，从中选择一个元素，以该元素为界将其余元素划分为两个子集， 一个子集中的所有元素都小于该元索，另一个子集中的所有元素都大于或等于该元素。对这 样两个子集递归执行这一过程，当某个子集中的元素数小于 2 时，这个子集就不需要再次排 序，终止递归。

归并不节省存储器的开销，因为递归调用过程中必须在某个地方维护一个存储处理值 的栈。递归的执行速度并不快，但递归代码比较紧凑，并且比相应的非递归代码更易于编写 与理解。在描述树等递归定义的数据结构时使用递归尤其方便。
## 4.11 C预处理器
### 4.11.1 文件包含
文件包含指令(即#include 指令)使得处理大量的#define 指令以及声明更加方便。

如果文件名用引号引起来，则在源文件所在 位置查找该文件;如果在该位置没有找到文件，或者如果文件名是用尖括号<与>括起来的， 则将根据相应的规则查找该文件，这个规则同具体的实现有关。被包含的文件本身也可包含 #include 指令。

源文件的开始处通常都会有多个#include 指令，它们用以包含常见的#define 语句和 extern 声明，或从头文件中访问库函数的函数原型声明

大的程序中，#include 指令是将所有声明捆绑在一起的较好的方法。它保证所有的 源文件都具有相同的定义与变量声明，这样可以避免出现一些不必要的错误。
### 4.11.2 宏替换
宏定义的形式如下:

#define 名字 替换文本

#define 指令中的名字与变量名的命名方式相同，替换文本可以是任意字符串。通常情况下， #define 指令占一行，替换文本是#define 指令行尾部的所有剩余部分内容，但也可以把一 个较长的宏定义分成若干行，这时需要在待续的行末尾加上一个反斜杠符\。#define 指令 定义的名字的作用域从其定义点开始，到被编译的源文件的末尾处结束。宏定义中也可以使 用前面出现的宏定义。替换只对记号进行，对括在引号中的字符串不起作用。

宏定义也可以带参数，这样可以对不同的宏调用使用不同的替换文本。

可以通过#undef 指令取消名字的宏定义，这样做可以保证后续的调用是函数调用，而不 是宏调用

形式参数不能用带引号的字符串替换。但是，如果在替换文本中，参数名以#作为前缀则 结果将被扩展为由实际参数替换该参数的带引号的字符串。

在实际参数中，每个双引号"将被替换为\"，反斜杠\将被替换为\\，因此替换后的字符串是合法的字符串常量。
### 4.11.3 条件包含
#if 语句对其中的常量整型表达式(其中不能包含 sizeof、类型转换运算符或 enum 常 量)进行求值，若该表达式的值不等于 0，则包含其后的各行，直到遇到#endif、#elif 或 #else 语句为止(预处理器语句#elif 类似于 else if)。在#if 语句中可以使用表达式 defined(名字)，该表达式的值遵循下列规则:当名字已经定义时，其值为 1;否则，其值 为 0。
# 5 指针与数组
指针是一种保存变量地址的变量。
## 5.1 指针与地址
通常的机器都有一系列连 续编号或编址的存储单元，过些存储单元可以单个进行操纵，也可以以连续成组的方式操纵。 通常情况下，机器的一个字节可以存放一个 char 类型的数据，两个相邻的字节存储单元可存 储一个 short(短整型)类型的数据，而 4 个相邻的字节存储单元可存储一个 long(长整型) 类型的数据。指针是能够存放一个地址的一组存储单元(通常是两个或 4 个字节)。

一元运算符&可用于取一个对象的地址

```c
p = &c;
```
将把 c 的地址赋值给变量 p，我们称 p 为“指向”c 的指针。地址运算符&只能应用于内存中的对象，即变量与数组元素。它不能作用于表达式、常量或 register 类型的变量。

一元运算符*是间接寻址或间接引用运算符。当它作用于指针时，将访问指针所指向的对 象。
```c
int x = 1, y = 2, z[10];
int *ip; /* ip is a pointer to int */

 y=*ip; /*ipnowpointstox*/
 *ip=0; /*yisnow1*/
ip=&x; /*xisnow0*/
ip = &z[0]; /* ip now points to z[0] */
```

指针只能指向某种特定类型的对象，也就是说，每个指针都必须指向某 种特定的数据类型。

一元运算符*和&的优先级比算术运算符的优先级高，

语句(*ip)++ 中的圆括号是必需的，否则，该表达式将对 ip 进行加 1 运算， 而不是对 ip 指向的对象进行加 1 运算，这是因为，类似于* 和++这样的一元运算符遵循从右 至左的结合顺序。

由于指针也是变量，所以在程序中可以直接使用，而不必通过间接引用 的方法使用。
## 5.2 指针与函数参数
